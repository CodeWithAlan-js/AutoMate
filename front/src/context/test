import React, {
  createContext,
  useContext,
  useReducer,
  useEffect,
  useState,
  useCallback,
} from "react";
import axios from "axios";
import { useUserContext } from "./userContext";
import io from "socket.io-client";

const UserTaskContext = createContext();

const initialTaskData = {
  ownerDetails: {
    lastName: "",
    firstName: "",
    phone: "",
  },
  vehicle: {
    brand: "",
    model: "",
    licencePlate: "",
    repairDetails: {
      diagnostic: "",
      partToOrder: "",
      ordered: false,
      price: 0,
      expectedTime: new Date(),
      completed: false,
    },
  },
};

const taskReducer = (state, action) => {
  switch (action.type) {
    case "UPDATE_FIELD":
      const { name, value } = action.payload;
      const keys = name.split(".");
      let newState = { ...state };

      let field = newState;
      for (let i = 0; i < keys.length - 1; i++) {
        field = field[keys[i]];
      }
      field[keys[keys.length - 1]] = value;

      return newState;
    case "RESET_TASK":
      return initialTaskData;
    case "SET_TASK_DATA":
      return { ...state, ...action.payload };
    default:
      return state;
  }
};

export const UserTaskProvider = ({ children }) => {
  const [task, setTask] = useState([]);
  const [error, setError] = useState("");
  const [isVisible, setIsVisible] = useState(false);
  const [modalIsVisible, setModalIsVisible] = useState(false);
  const [modalMessage, setModalMessage] = useState("");
  const [isEditing, setIsEditing] = useState(false);
  const [updateId, setUpdateId] = useState(null);

  const { user } = useUserContext();
  const [taskData, dispatch] = useReducer(taskReducer, initialTaskData);

  // Fonction pour récupérer les tâches
  const fetchTasks = useCallback(async () => {
    if (user) {
      try {
        const response = await axios.get(
          `http://localhost:3001/api/task/getTasks`,
          {
            withCredentials: true,
          }
        );
        setTask(response.data.tasks);
      } catch (error) {
        console.log(error);
      }
    }
  }, [user]);

  // Initialiser Socket.io et récupérer les tâches uniquement si l'utilisateur est connecté
  useEffect(() => {
    if (user) {
      const socket = io("http://localhost:3001");

      // Ecoute les tâches en temps réel
      socket.on("newTask", (newTask) => {
        setTask((prevTasks) => [...prevTasks, newTask]);
      });

      socket.on("updateTask", (updatedTask) => {
        setTask((prevTasks) =>
          prevTasks.map((task) =>
            task._id === updatedTask._id ? updatedTask : task
          )
        );
      });

      socket.on("deleteTask", (deletedTaskId) => {
        setTask((prevTasks) =>
          prevTasks.filter((task) => task._id !== deletedTaskId)
        );
      });

      // Récupère les tâches après la connexion
      fetchTasks();

      // Nettoyer la connexion socket à la déconnexion de l'utilisateur
      return () => {
        socket.disconnect();
      };
    }
  }, [user, fetchTasks]);

  const handleFieldChange = (e, name) => {
    const { value, type, checked } = e.target;
    const inputValue = type === "checkbox" ? checked : value;
    dispatch({ type: "UPDATE_FIELD", payload: { name, value: inputValue } });
  };

  return (
    <UserTaskContext.Provider
      value={{
        task,
        error,
        isVisible,
        taskData,
        handleFieldChange,
        setIsVisible,
        fetchTasks,
        isEditing,
        updateId,
        setUpdateId,
      }}
    >
      {children}
    </UserTaskContext.Provider>
  );
};

export const useUserTaskContext = () => {
  return useContext(UserTaskContext);
};
